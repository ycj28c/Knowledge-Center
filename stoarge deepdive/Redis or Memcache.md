[缓存知识扫盲](https://github.com/doocs/advanced-java)

## Redis 和 Memcache区别
两者都用于缓存服务器

1）集群  
redis 和memcached都支持集群

2）数据类型  
Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。其中Set是HashMap实现的，value永远为null而已
memcache支持简单数据类型，需要客户端自己处理复杂对象。可以认为只支持text，需要序列化和反序列化object。   

3）性能  
Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。

注意Redis6.0也开始引入多线程，不过多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。多线程的切换也是会有消耗的。

4）IO角度  
从IO角度来说，Redis选用的I/O多路复用模型，虽然单线程不用考虑锁等问题，但是还要执行kv数据之外的一些排序、聚合功能，复杂度比较高。memcache也选用非阻塞的I/O多路复用模型，速度更快一些。

5）持久性  
redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 
memcache不支持数据持久存储 

结论：  
所以在应用场景上单机多核的话用memcache性能更高一点，此外都应该用redis。

## 为什么要用缓存  
高性能，高并发，一个query跑2分钟，一个cache不到2ms就返回结果了，显而易见。

## Redis有哪些数据类型
啥都有啊Strings，Hashs，Lists，Sets，Sorted Set，Bitmaps等。

缓存是使用最多的场景了，对于字符串和数字可以直接存取。不过更多时候面临的是需要将一个结构体或者对象里的数据缓存起来。存储时可以将结构化数据先序列化，再set到redis中，查询时，先get到后再反序列化到对象中。缓存的话也就是Strings的用法，key，value存放一个object，memcache就是这部分功能。java通过spring可以方便管理。

但是其实redis还能做其他事情的，比如排行榜，ID键值（当然最广泛的是Twitter的SnowFlake算法），队列等，效率高。具体看[Redis能用来做什么](https://juejin.im/post/6844903906082816007)

//TODO 发掘更多的用处

## Redis的过期策略都有哪些
过期策略：  
定期删除+惰性删除（lazy delete），定期删除就是每100ms删除一些过期的key，这是贪婪删除，不保证全部删除。惰性删除就是获取的时候，如果已经过期就返回null了。

内存淘汰机制：  
如果惰性删除和定期删除不够，剩余太多怎么办，那就用内存淘汰了，比如lru，random之类的，当然手写LRU练过很多次了（包括LinkedHashMap和直接用doublelinkedlist写）。

## Redis的高并发高可用如何保证
主要是考虑redis如何抗压，如何扩容，挂了怎么办？  

一种是主从架构，一主多从，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。

如果集群架构，宕机没事，如果是主从，需要加上replica，哪个节点宕了上备机。

1）判断节点宕机  
如果一个节点认为某个节点pfail了，那么会在gossip ping消息中， ping 给其他节点，如果超过半数的节点都认为pfail了，那么就会变成 fail。

2）master宕机  
对宕机的master node，从其所有的slave node中，选择一个切换成master node。  

3）如果选举master  
每个slave判断与master的传输时间，然后所有master进行投票，超过半数投票某个节点，那么该slave称为master，（该节点主备切换，备机成为slave，主机成为master）

## Redis的持久化和快速恢复
如果redis挂了不能快速恢复，可能引起雪崩。  
持久化有RDB（数据周期性持久化）和AOF两种（日志的方式），显然RDB是有时间间隔，恢复速度快，适合冷备，而AOF可以保证就可能少的数据丢失，而且也可以恢复应急错误（删除日志重启），当然也可以两个都用（如果钱多）。

## Redis集群模式的工作原理
还包括key如何寻址，分布式寻址算法，consistent hashing之类。  

Redis Cluster主要针对于海量数据+高并发+高可用场景。cluster模式下，还需要额外的端口在节点间进行数据交换。

1）节点间的内部通信机制  
集群metadata维护通过两种：集中式和gossip，集中式就是将数据都存放在master节点上，而redis使用的是gossip，也就是每个node都存放一份元数据，任何节点的变更都会不停的发送给其他节点。

集中式的好处是metadata的更新时效性高，一变化就更新到了master中，但是master宕机了就乱套了（不过可以replication）。gossip因为有延迟，可能会读取到滞后的数据。

2）分布式寻址算法  
*hash算法  
就是最普通的mod算法了。不过当master宕机，mod就需要全部重新分配，导致cache丢失。

*consistent hashing  
自动缓存迁移+虚拟节点（也就是自动复杂均衡），就是node宕机后全部数据移动到了后一个node，为了防止数据量过大造成下一个也宕了，使用虚拟节点负载均衡。（具体机制看consistent hashing文章，容易忘）

*redis自带的hash slot算法  
因为redis cluster固定16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的 hash slot。当增加master，移动变化的节点，而当一台master宕机，另外的master不会受到影响，因为hash slot没有变。

## Redis缓存雪崩和穿透
1）缓存雪崩（Cache avalanche）  
假设有如下一个系统，高峰期请求为5000次/秒，4000次走了缓存，只有1000次落到了数据库上，数据库每秒1000的并发是一个正常的指标，完全可以正常工作，但如果缓存宕机了，每秒5000次的请求会全部落到数据库上，数据库立马就死掉了，因为数据库一秒最多抗2000个请求，如果DBA重启数据库，立马又会被新的请求打死了，这就是缓存雪崩。  

如何解决缓存雪崩？  
事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃  
事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL被打死  
事后：redis持久化，快速恢复缓存数据  

2）缓存穿透（cache penetration）  
假如客户端每秒发送5000个请求，其中4000个为黑客的恶意攻击，即在数据库中也查不到。举个例子，用户id为正数，黑客构造的用户id为负数，
如果黑客每秒一直发送这4000个请求，缓存就不起作用，数据库也很快被打死。

如何解决缓存穿透？  
查询不到的数据也放到缓存，value为空，如set -999 “”

## 如何保证缓存和数据库读写一致性
1）Cache Adide Pattern
读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先更新数据库，然后再删除缓存。注意删除缓存而不是更新，避免读取脏数。

（可以在修改数据的API里面包含删除缓存，用事务）

在大量数据下会出现数据不一致情况，因为数据库更新比较慢，可能让缓存读取到了旧数据。解决方法是使用queue来更新，在读取时候如果数据不在缓存，重新执行“读取数据+更新缓存”操作（入queue）。如果这个请求可能耗时太久，业务可以直接从数据库中读取。缺点是这个queue可能有重复的操作，另外积压太多也会导致大量超时。正式上线需要压力测试，不够的话要加机器。

## Redis的并发竞争问题
如何解决，CAS方案。  
某个时刻，多个系统实例都去更新某个key。可以*基于zookeeper实现分布式锁*。每个系统通过zookeeper获取分布式锁，确保同一时间，只能有一个系统实例在操作某个key，别人都不允许读和写。你要写入缓存的数据，都是从mysql里查出来的，都得写入mysql中，写入mysql中的时候必须保存一个*时间戳*，从mysql查出来的时候，时间戳也查出来。

//TODO 关于redis锁和zookeeper锁的深入

## Redis集群部署
你的Redis是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上Redis给几个G的内存？设置了哪些参数？压测后你们Redis集群承载多少QPS？  
 
例子：  
Redis cluster，10台机器，5台机器部署了Redis主实例，另外5台机器部署了Redis的从实例，每个主实例挂了一个从实例，5个节点对外提供读写服务，每个节点的读写高峰 QPS可能可以达到每秒5万，5台机器最多是25万读写请求每秒。

机器是什么配置？32G 内存+ 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。5 台机器对外提供读写，一共有 50g 内存。

因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。

你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。

其实大型的公司，会有基础架构的 team 负责缓存集群的运维。

## Reference
[redis和Memcached的区别，都什么时候使用？](https://blog.csdn.net/lhx574938077/article/details/81838819)  
[面试题：“选redis还是memcache”](https://juejin.im/post/6844903841612169230)
