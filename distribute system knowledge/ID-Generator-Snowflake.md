分布式系统或者很多服务都需要单独的ID生成机制

## ID生成器方案
通常有以下几种：  
1)数据库自增长ID  
属于完全依赖数据源的方式，所有的ID存储在数据库里，是最常用的ID生成办法，在单体应用时期得到了最广泛的使用，建立数据表时利用数据库自带的auto_increment作主键，或是使用序列完成其他场景的一些自增长ID的需求。

优点：非常简单，有序递增，方便分页和排序。  
缺点：分库分表后，同一数据表的自增ID容易重复，无法直接使用（可以设置步长，但局限性很明显）；性能吞吐量整个较低，如果设计一个单独的数据库来实现 分布式应用的数据唯一性，即使使用预生成方案，也会因为事务锁的问题，高并发场景容易出现单点瓶颈。  
适用场景：单数据库实例的表ID（包含主从同步场景），部分按天计数的流水号等；分库分表场景、全系统唯一性ID场景不适用。  

2)Redis生成ID  
也属于完全依赖数据源的方式，通过Redis的INCR/INCRBY自增原子操作命令，能保证生成的ID肯定是唯一有序的，本质上实现方式与数据库一致。

优点：整体吞吐量比数据库要高。  
缺点：Redis实例或集群宕机后，找回最新的ID值有点困难。  
适用场景：比较适合计数场景，如用户访问量，订单流水号（日期+流水号）等。  

3)UUID、GUID生成ID  
UUID：按照OSF制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得）

GUID：微软对UUID这个标准的实现。UUID还有其它各种实现，不止GUID一种，不一一列举了。

这两种属于不依赖数据源方式，真正的全球唯一性ID

优点：不依赖任何数据源，自行计算，没有网络ID，速度超快，并且全球唯一。  
缺点：没有顺序性，并且比较长（128bit），作为数据库主键、索引会导致索引效率下降，空间占用较多。  
适用场景：只要对存储空间没有苛刻要求的都能够适用，比如各种链路追踪、日志存储等。  

4)snowflake算法（雪花算法）生成ID  
属于半依赖数据源方式，原理是使用Long类型（64位），按照一定的规则进行填充：时间（毫秒级）+集群ID+机器ID+序列号，每部分占用的位数可以根据实际需要分配，其中集群ID和机器ID这两部分，在实际应用场景中要依赖外部参数配置或数据库记录。

优点：高性能、低延迟、去中心化、按时间有序  
缺点：要求机器时钟同步（到秒级即可）  
适用场景：分布式应用环境的数据主键  
雪花ID算法听起来是不是特别适用分布式架构场景？照目前来看是的，接下来我们重点讲解它的原理和最佳实践。  

## Snowflake生成器
这是twitter提出的，包括4个部分

1)1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0  
2)41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 后得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L << 41) / (1000L * 60 * 60 * 24 * 365) = 69  
3)10位的数据机器位，可以部署在1024个节点，包括10位workerId  
4)12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号  

加起来刚好64位，为一个Long型。

其中只是一个标准，具体的话可以自己按照业务需求调整。说白了就是一个折中的方法，大小比较小，一个局部的分布式完全够用，速度也够快，够简单。

## Reference
[漫画：什么是SnowFlake算法？](https://blog.csdn.net/bjweimengshu/article/details/80162731)  
[一篇文章彻底搞懂snowflake算法及百度美团的最佳实践](http://www.spring4all.com/article/17333)  
[Twitter Snowflake算法详解](https://blog.csdn.net/yangding_/article/details/52768906)